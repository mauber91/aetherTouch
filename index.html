<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Anadolâ€‘style WebGL Demo (CDN)</title>
<style>body{margin:0;background:#111}</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.150.0/build/three.module.js';
import { vertexShader as glitchVertexShader, fragmentShader as glitchFragmentShader } from '../shaders/glitch.js';
import { vertexShader as meshVertexShader, fragmentShader as meshFragmentShader } from '../shaders/mesh.js';

let scene, camera, renderer, clock, mesh;

const uniforms = {
  uTime: { value: 0 },
  uResolution: { value: new THREE.Vector2() },
  uNoiseTex: { value: null },
  uBreak: { value: 0 } // Add break uniform
};

let composer, glitchMaterial, quadScene, quadCamera, renderTarget;

init();
animate();

function init(){
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, .1, 100);
  camera.position.set(0,0,4);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  clock = new THREE.Clock();

  const geometry = new THREE.IcosahedronGeometry(1.5,8);
  const mat = new THREE.ShaderMaterial({
    vertexShader: meshVertexShader,
    fragmentShader: meshFragmentShader,
    uniforms,
    side: THREE.DoubleSide,
    transparent:true
  });

  mesh = new THREE.Mesh(geometry,mat);
  scene.add(mesh);

  const texLoader = new THREE.TextureLoader();
  texLoader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSPhRlSO_6eD9vIWJdqZUakYAZ2U12d9HtwIg&s', tex=>{
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    uniforms.uNoiseTex.value = tex;
  });

  // Create a render target for post-processing
  renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);

  // Fullscreen quad scene for post-processing
  quadScene = new THREE.Scene();
  quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

  glitchMaterial = new THREE.ShaderMaterial({
    uniforms: {
      tDiffuse: { value: null },
      uTime: { value: 0.0 },
      uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
    },
    vertexShader: glitchVertexShader,
    fragmentShader: glitchFragmentShader,
    transparent: false
  });

  const quadGeometry = new THREE.PlaneGeometry(2, 2);
  const quad = new THREE.Mesh(quadGeometry, glitchMaterial);
  quadScene.add(quad);

  window.addEventListener('resize', onResize, false);
  uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
}

function onResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
  uniforms.uResolution.value.set(window.innerWidth,window.innerHeight);

  // Resize render target and post effect
  renderTarget.setSize(window.innerWidth, window.innerHeight);
  glitchMaterial.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
}

function animate(){
  requestAnimationFrame(animate);
  uniforms.uTime.value += clock.getDelta()*0.5;

  // Render scene to texture
  renderer.setRenderTarget(renderTarget);
  renderer.render(scene, camera);
  renderer.setRenderTarget(null);

  // Pass texture and time to glitch shader
  glitchMaterial.uniforms.tDiffuse.value = renderTarget.texture;
  glitchMaterial.uniforms.uTime.value = uniforms.uTime.value;

  // Render fullscreen quad with glitch effect
  renderer.render(quadScene, quadCamera);
}

// Mouse interaction for breakup
window.addEventListener('mousemove', e => {
  // Normalize mouse to [-1,1]
  const mx = (e.clientX / window.innerWidth) * 2 - 1;
  const my = -(e.clientY / window.innerHeight) * 2 + 1;

  // Project mesh center to screen
  const meshPos = mesh.position.clone().project(camera);
  // Distance from mouse to mesh center
  const dist = Math.sqrt(Math.pow(mx - meshPos.x, 2) + Math.pow(my - meshPos.y, 2));
  // If close, increase breakup
  uniforms.uBreak.value = Math.max(0, 1.0 - dist * 1.5);
});

// Fade out breakup when mouse leaves
window.addEventListener('mouseleave', () => {
  uniforms.uBreak.value = 0;
});
</script>
</body>
</html>
